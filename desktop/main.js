const { app, BrowserWindow, dialog } = require("electron");
const path = require("path");
const fs = require("fs");
const { spawn, spawnSync } = require("child_process");
const http = require("http");
const crypto = require("crypto");

const PORT = Number(process.env.LARAVEL_PORT) || 8765;
const HOST = "127.0.0.1";
const APP_TITLE = "Your App";
const isDev = !app.isPackaged;

let phpProcess;

function getLaravelRoot() {
  const p = isDev ? path.resolve(__dirname, "..") : path.join(process.resourcesPath, "laravel");
  console.log("[boot] laravelRoot =", p);
  return p;
}

function candidatesPHP() {
  const envBin = process.env.PHP_BIN;
  const list = [];
  if (envBin) list.push(envBin);
  if (process.platform === "win32") {
    list.push(
      path.join(process.resourcesPath, "php", "win", "php.exe"),
      "C:\\php\\php.exe",
      "php.exe"
    );
  } else {
    list.push(
      path.join(process.resourcesPath, "php", "mac", "php"),
      "/opt/homebrew/bin/php",
      "/usr/local/bin/php",
      "/usr/bin/php",
      "php"
    );
  }
  return list;
}

function getPhpBinary() {
  for (const p of candidatesPHP()) {
    try {
      if (p.includes("/") || p.includes("\\")) {
        if (fs.existsSync(p)) return p;
      } else {
        const which = spawnSync(process.platform === "win32" ? "where" : "which", [p], { shell: true });
        if (which.status === 0)
          return which.stdout.toString().split(/\r?\n/).filter(Boolean)[0].trim();
      }
    } catch {}
  }
  return null;
}

function waitFor(url, timeoutMs = 60000, intervalMs = 500) {
  const start = Date.now();
  return new Promise((resolve, reject) => {
    (function ping() {
      http
        .get(url, (res) => {
          if (res.statusCode === 200) resolve();
          else {
            if (Date.now() - start > timeoutMs)
              reject(new Error(`Timeout (status ${res.statusCode})`));
            else setTimeout(ping, intervalMs);
          }
        })
        .on("error", () => {
          if (Date.now() - start > timeoutMs)
            reject(new Error("Timeout waiting for Laravel"));
          else setTimeout(ping, intervalMs);
        });
    })();
  });
}

function getOrCreateAppKey(userDataDir) {
  const keyFile = path.join(userDataDir, "appkey.txt");
  if (fs.existsSync(keyFile)) return fs.readFileSync(keyFile, "utf8").trim();
  const key = "base64:" + Buffer.from(crypto.randomBytes(32)).toString("base64");
  fs.writeFileSync(keyFile, key);
  return key;
}

function prepareRuntimePaths() {
  const userData = app.getPath("userData");
  const storagePath = path.join(userData, "storage");
  const frameworkPath = path.join(storagePath, "framework");
  const viewsPath = path.join(frameworkPath, "views");
  const cachePath = path.join(frameworkPath, "cache");
  const cacheDataPath = path.join(cachePath, "data");
  const sessionsPath = path.join(frameworkPath, "sessions");
  const logsPath = path.join(storagePath, "logs");
  const dbPath = path.join(userData, "database.sqlite");
  const phpTmp = path.join(userData, "php-tmp");         // NEW: temp dir for uploads
  const phpConfDir = path.join(userData, "php-conf");    // NEW: we’ll put php.ini here (Windows only)

  fs.mkdirSync(viewsPath, { recursive: true });
  fs.mkdirSync(cacheDataPath, { recursive: true });
  fs.mkdirSync(sessionsPath, { recursive: true });
  fs.mkdirSync(logsPath, { recursive: true });
  fs.mkdirSync(phpTmp, { recursive: true });
  fs.mkdirSync(phpConfDir, { recursive: true });

  if (!fs.existsSync(dbPath)) fs.writeFileSync(dbPath, "");

  console.log("[boot] userData =", userData);
  console.log("[boot] storagePath =", storagePath);
  console.log("[boot] sqlite =", dbPath);
  console.log("[boot] viewsPath =", viewsPath);

  return { userData, storagePath, dbPath, viewsPath, phpTmp, phpConfDir };
}

function runArtisanSync(laravelRoot, phpBin, args, env) {
  console.log("[artisan]", ["artisan", ...args].join(" "));
  const res = spawnSync(`"${phpBin}"`, ["artisan", ...args], {
    cwd: laravelRoot,
    env,
    shell: true,
    stdio: "pipe",
  });
  if (res.error) throw res.error;
  if (res.status !== 0) {
    console.warn(
      "[artisan] exit",
      res.status,
      "\n",
      res.stdout?.toString(),
      "\n",
      res.stderr?.toString()
    );
  }
  return res;
}

/** ---------- Minimal addition: ensure php.ini on Windows enables fileinfo ---------- */
function ensurePhpIniWindows(phpDir, phpConfDir, phpTmp) {
  if (process.platform !== "win32") return null;

  const extDir = path.join(phpDir, "ext");
  const iniPath = path.join(phpConfDir, "php.ini");

  const lines = [
    "; autogenerated php.ini for Electron Laravel runtime (Windows)",
    "file_uploads=On",
    "upload_max_filesize=32M",
    "post_max_size=32M",
    `upload_tmp_dir=${phpTmp.replace(/\\/g, "/")}`,
    "date.timezone=UTC",
    "expose_php=0",
  ];

  if (fs.existsSync(extDir)) {
    lines.push(`extension_dir=${extDir.replace(/\\/g, "/")}`);
    // Enable fileinfo if bundled (and a few commonly-needed dlls if present)
    const enableIfExists = (name) => {
      const dll = path.join(extDir, `${name}.dll`);
      if (fs.existsSync(dll)) lines.push(`extension=${name}`);
    };
    enableIfExists("fileinfo");   // <<< THIS fixes FilePond mime detection
    enableIfExists("openssl");
    enableIfExists("pdo_sqlite");
    enableIfExists("sqlite3");
    enableIfExists("mbstring");
    enableIfExists("curl");
    enableIfExists("gd");
    enableIfExists("exif");
    enableIfExists("iconv");
  } else {
    // fallback: let PHP search default dir but still try to enable fileinfo
    lines.push("extension=fileinfo");
  }

  fs.writeFileSync(iniPath, lines.join("\n") + "\n");
  return iniPath;
}

async function startLaravel() {
  const laravelRoot = getLaravelRoot();
  const phpBin = getPhpBinary();
  const phpDir = phpBin ? path.dirname(phpBin) : "";

  if (!phpBin) {
    const msg = [
      "PHP binary not found.",
      "Fix:",
      "- macOS: brew install php",
      "- Or set PHP_BIN=/opt/homebrew/bin/php",
      "- Or bundle portable PHP in desktop/build/php/...",
    ].join("\n");
    console.error("[boot] " + msg);
    dialog.showErrorBox("PHP not found", msg);
    throw new Error("PHP not found");
  }

  console.log("[boot] phpBin =", phpBin);

  const { userData, storagePath, dbPath, viewsPath, phpTmp, phpConfDir } = prepareRuntimePaths();
  const appKey = getOrCreateAppKey(userData);

  // NEW (Windows only): create php.ini we control and point PHPRC to it,
  // so php.exe loads fileinfo even on clean machines.
  let phprc = process.env.PHPRC || undefined;
  if (process.platform === "win32") {
    const iniPath = ensurePhpIniWindows(phpDir, phpConfDir, phpTmp);
    if (iniPath) {
      phprc = phpConfDir; // point PHP to our writable ini folder
      console.log("[php] using PHPRC =", phprc);
    }
  }

  const env = {
    ...process.env,
    APP_ENV: "production",
    APP_DEBUG: "false",
    APP_KEY: appKey,
    APP_STORAGE: storagePath,
    LOG_CHANNEL: "errorlog",
    SESSION_DRIVER: "cookie",
    CACHE_STORE: "file",
    QUEUE_CONNECTION: "sync",
    DB_CONNECTION: "sqlite",
    DB_DATABASE: dbPath,
    VIEW_COMPILED_PATH: viewsPath,
    PHPRC: process.platform === "win32" ? phprc : process.env.PHPRC, // << use our ini on Windows
    PATH:
      process.platform === "win32"
        ? `${phpDir};${process.env.PATH}`
        : process.env.PATH,
  };

  try {
    runArtisanSync(laravelRoot, phpBin, ["config:clear"], env);
  } catch {}

  try {
    console.log("[migrate] running migrations ...");
    runArtisanSync(
      laravelRoot,
      phpBin,
      ["migrate", "--force", "--no-interaction"],
      env
    );
  } catch (e) {
    console.warn("[migrate] failed:", e);
  }

  try {
    if (isDev) {
      console.log("[seed] dev mode → reseeding always");
      runArtisanSync(
        laravelRoot,
        phpBin,
        ["db:seed", "--force", "--no-interaction"],
        env
      );
    } else {
      const seedMarker = path.join(userData, "seeded-v1.txt");
      const always = process.env.SEED_ALWAYS === "1";
      if (always || !fs.existsSync(seedMarker)) {
        const classes = (process.env.SEED_CLASSES || "")
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);

        if (classes.length) {
          for (const cls of classes) {
            console.log("[seed] db:seed --class", cls);
            runArtisanSync(
              laravelRoot,
              phpBin,
              [
                "db:seed",
                "--force",
                "--no-interaction",
                "--class",
                cls,
              ],
              env
            );
          }
        } else {
          console.log("[seed] db:seed (all)");
          runArtisanSync(
            laravelRoot,
            phpBin,
            ["db:seed", "--force", "--no-interaction"],
            env
          );
        }

        fs.writeFileSync(seedMarker, new Date().toISOString());
        console.log("[seed] completed (marker written)");
      } else {
        console.log("[seed] skipped (already seeded)");
      }
    }
  } catch (e) {
    console.warn("[seed] failed:", e);
  }

  console.log("[boot] starting php artisan serve ...");
  phpProcess = spawn(
    `"${phpBin}"`,
    ["artisan", "serve", `--host=${HOST}`, `--port=${PORT}`],
    {
      cwd: laravelRoot,
      env,
      shell: true,
      detached: false,
    }
  );

  phpProcess.on("error", (err) => console.error("[php] spawn error:", err));
  phpProcess.stdout.on("data", (d) => process.stdout.write(`[php] ${d}`));
  phpProcess.stderr.on("data", (d) => process.stderr.write(`[php] ${d}`));
  phpProcess.on("close", (code) =>
    console.log("[php] exited with code", code)
  );
}

function stopLaravel() {
  if (!phpProcess) return;
  try {
    if (process.platform === "win32") {
      spawn("taskkill", ["/pid", phpProcess.pid, "/t", "/f"]);
    } else {
      phpProcess.kill("SIGTERM");
    }
  } catch (e) {
    console.error("Failed to stop PHP:", e);
  }
}

async function createWindow() {
  const win = new BrowserWindow({
    width: 1280,
    height: 820,
    title: APP_TITLE,
    autoHideMenuBar: true,
  });

  try {
    const url = `http://${HOST}:${PORT}/up`;
    console.log("[boot] waiting for", url);
    await waitFor(url, 60000, 700);
    await win.loadURL(`http://${HOST}:${PORT}`);
  } catch (e) {
    console.error("[boot] waitFor failed:", e);
    dialog.showErrorBox(
      "Startup error",
      "Could not reach the Laravel server."
    );
  }
}

app.whenReady().then(async () => {
  await startLaravel();
  await createWindow();
  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on("before-quit", stopLaravel);
app.on("window-all-closed", () => {
  stopLaravel();
  if (process.platform !== "darwin") app.quit();
});
